gRPC/gNMI
=========

*Сверхлихие 20-е*

За последние лет семь `gRPC <https://grpc.io/docs/>`_ уже всем уши прожужжали. И только самые ловкие разработчики могли избежать реализации взаимодействия с какой-нибудь системой по gRPC.

    "g" в *gRPC*, кстати, `означает вовсе не "google" <https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md>`_.


gRPC
----

Вообще-то RPC вроде бы как начал давным давно уходить в тень, уступая место REST и ему подобным. Но в недрах гугла он цвёл, эффективно связывая между собой микросервисы, и назывался Stubby. Ровно до тех пор пока, в 2015 они не решили его переписать и заопенсорсить, чтобы нанести непоправимую пользу миру. 

| Долгое время в изученной Вселенной не существовало никаких общедоступных библиотек, позволяющих реализовать какой-то типовой RPC. Разработчики сами описывали и сообщения, и формат данных в них, и как их интерпретировать. Поэтому и популярности особой он не сыскал.
| А тут вот, пожалте: готовый протокол, стек, формат данных и библиотеки для кучи языков.
| Что же он из себя представляет?

| Это фреймворк, позволяющий приложениям, запущенным в совершенно разных окружениях, взаимодействовать друг с другом посредством RPC.
| Делает gRPC концептуально ровно то, что предполагается самой идеологией RPC, но есть несколько вещей, которые обусловили его успех и популярность:

1. Строгий IDL (Interface Definition Language), диктующий то, как именно описывать спецификации - protocol buffers или protobufs.
2. Готовый формат данных и механизм их маршалинга и демаршалинга - тоже protocol buffers (protobufs).
3. Библиотеки для разных языков программирования, которые на основе спецификации генерируют объекты языка (классы, методы итд) - разработчику остаётся только использовать их. Как для сервера, так и для клиента.

То есть.
Поставил себе пакет grpc: перед тобой сразу язык спецификации, генераторы кода, интерфейсы, форматы данных, транспорт.  Красота-тра-та-та!

| Мы не знаем сколько лет внутри гугла gRPC набирал популярность и проникал всё глубже в межсервисное взаимодействие. Но что теперь известно точно, так это то, что у них менеджмент с яйцами, а сетевые инженеры достаточно гибки и пытливы, чтобы и к сети адаптировать этот единый протокол.
| При этом не забываем, что на проприетарные джуносы, иосы и врп никто не притащит свой бинарничек, чтобы удобный для себя интерфейс реализовать. Это значит, что white-box коммутаторы с собственной linux OS у гугла появились задолго до того как их увидел мир.
| Что и неудивительно - с железом они работать умеют, с Linux и подавно - дело было за малым - собрать команду Network R&D, в которой будут ребята, которые занимались разработкой своих серверов и адаптацией интерфейсов и инструментов, и найти достаточно гибкого вендора. А за последним дело не встанет, когда вы закупаете килограмм свичтей в секунду.

    .. figure:: https://fs.linkmeup.ru/images/adsm/5/cool-networkers.png
           :width: 800
           :align: center
    
    *Так по мнению поисковых систем выглядят крутые сетевики*

Вообще для обывателей всё началось 24 сентября 2015, когда OpenConfig consortium выпустил OpenConfig в мир. Весь FANG (кроме Amazon) поучаствовал в этом консорциуме. Но начал всю заварушку и продолжает её паровозить гугл. Естественно, среди них и крупные телекомы, вроде Level3, AT&T, Verizon, Bell. 

И пока OpenConfig прокладывал себе дорогу, раскидывая в сторону вендорские и IETF модели, гугл сделал следующий шаг - как раз таки реализовал gNMI.

Итак, в 2016-м `мир увидел <https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md#7-revision-history>`_ плод труда инженеров гугл - протокол **gNMI**, реализующий весь стек технологий для программного взаимодействия с железом. 

| И что с того?! Ведь к тому времени буйным цветом шёл NETCONF и к тому же почти одновременно с gNMI уже почти сформировался RFC 8040, описывающий RESTCONF со вполне ещё модным на тот момент REST.
| Как в таких условиях пробиться ещё одному протоколу и не стать героем известной картинки?

    .. figure:: https://fs.linkmeup.ru/images/adsm/5/standards_2x.png
           :width: 500
           :align: center
    
    `Источник <https://xkcd.com/927/>`_

| Так вот, рассказываю: собрались как-то сетевики гугл вместе, пришли на встречу `IETF 98 <https://datatracker.ietf.org/meeting/98/materials/slides-98-rtgwg-gnmi-intro-draft-openconfig-rtgwg-gnmi-spec-00>`_ в Чикаго на секцию Routing Area Working 
| Group и прямым текстом им заявили, что то, что те навыдумывали, пора пришла заменить на `молодёжные технологии <https://github.com/openconfig/reference/tree/master/rpc/gnmi>`_.
| Шёл 2017-й год. Марат устроился в Яндекс.

И... Ничего не изменилось. 

В 2018 они, видимо, поняли, что их не услышали и на `IETF 101 <https://datatracker.ietf.org/meeting/101/materials/slides-101-netconf-grpc-network-management-interface-gnmi-00>`_ снова пришли с рассказом про gNMI, и уже более явно сообщали, что он пришёл на замену этим вашим x-CONF'ам. Слышите вы, старпёры? Ало?! gNMI пришёл!

И тут завертелось! Сообщество сетевых автоматизаторов из вендоров, телекомов и просто одиноких пассионариев понесло благую весть в народ.

| Как вы видите, gNMI молодой и дерзкий протокол. Про него нет страницы на вики, довольно скромное количество материалов и мало кто рассказывает о том, как его использует в своём проде.
| Он не является стандартом согласно любым организациям и RFC, но его спецификация описана на `гитхабе <https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md>`_.

Однако свою дорогу в мир прокладывает. Медленно, но, похоже, что верно.

| Что нам важно знать о нём? gRPC Network Management Interface.
| Это протокол управления сетевыми устройствами, использующий gRPC как фреймворк: транспорт, режимы взаимодействия (унарный и все виды стриминга), механизмы маршаллинга данных, proto-файлы для описания спецификаций.
| В качестве модели данных он может использовать YANG-модели, а может и не использовать - protobuf'ы можно сгенерировать на основе чего угодно, и даже просто написать вручную.

| Как того требует gRPC, на сетевом устройстве запускается сервер, а на системе управления - клиент. На обеих сторонах должна быть одна спецификация, одна модель данных. 
| gNMI в мир пришёл под руку с OpenConfig, но неразрывно они друг с другом не связаны. 

А ещё, что немаловажно, gNMI приводит с собой стриминг телеметрии. Впервые в истории хоть кто-то наконец подумал о том, что push-модель на сетевом устройстве может быть эффективнее pull, как делали системы мониторинга на основе CLI, SNMP и NETCONF. Можно подписаться на рассылку и хоть несколько раз в секунду получать метрики и даже анализировать утилизацию буфера на чипе. И для всех этих данных есть модели, позволяющие удобно с ними работать.

В этой статье я не копаю глубоко в каждый протокол и фреймворк, не разбираюсь, как они устроены, а даю только взгляд на историю развития автоматизации. За деталями приглашаю во `шестую часть <https://adsm.readthedocs.io/ru/latest/6_interfaces/index.html>`_.
